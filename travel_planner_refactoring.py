# we are receiving inputs from the mobile phone

# 	we are receiving the startCity
# 	we are receiving the startDate
# 	we are receiving the cities
# 	we are receiving the days
# 	we are receiving the routes ## ok

# make a function that take care of days 

from traveler_planner import printRoutePossibilities
from combinations import printCombinations
from combinations_on_list import printCombinationsArray
from depth_first_traversal import find_all_paths2
from permutations_origin import permutationsFromOrigin
from permutations_origin import permutationsReturnOrigin
from collections import defaultdict
from random import uniform
from list_of_dates import printListOfDates
from graph import Graph
import timeit
from datetime import date

# USER INPUTS
routes = [('MADRID','GRECE'),('MADRID','LISBONNE'),('GRECE','LISBONNE'),('GRECE','MADRID'),('LISBONNE','GRECE'),('LISBONNE','MADRID')] # generated by virtual table in sql on the device
days = [0,1,2]
startDate = date(2017, 1, 2)
#startCity = "MADRID"
cities = ["MADRID","GRECE","LISBONNE"]

# OUTPUT
### TODO





def transformArray(routes):
	""" 
	take in argument routes and return it in a better format 
	time : 0.004s
	"""
	array=[]
	for couple in routes:
		array.append(couple[0]+ "-" +couple[1])

	return array

#print(transformArray(routes))

def transformArray2(routes):
	""" 
	take in argument routes and return it in a better format 
	time : 0.004s
	"""
	array=[]
	for couple in routes:
		array.append(couple+ "-" +couple)

	return array


#WHAT WE HAVE IN DATABASE (prices)
def createFakePriceDatabase(routes):
	"""
	take in argument the routes generated by the device with the ryanair database of airports routes and return a fake database of prices 
	time : 1.7s
	"""

	transformedArray = transformArray(routes)
	priceDatabase = {key:[int(round(uniform(20, 180))) for _ in range(364)] for key in transformedArray}

	return priceDatabase

# GENERATED WITH USER INPUTS
def createOptimizedGraph(routes):
	""" 
	take the routes user inputs generated by sql and return an optimized graph
	time : 0.007s
	"""

	graphClass = Graph(routes, directed=True)

	return graphClass.getGraph()

def optimizedRoutePossibilities(routes,cities):
	""" 
	take in argument routes and return all the paths via dfs
	time : 0.16s
	"""
	graph = createOptimizedGraph(routes)
	for couple in permutationsFromOrigin(cities):
		if couple is not None:
			#yield find_all_paths2(graph,couple[0],couple[1])[0]
			print(find_all_paths2(graph,couple[0],couple[1])[0])

#optimizedRoutePossibilities(routes,cities)

def optimizedRoutePossibilities2(routes,cities):
	""" 
	take in argument routes and return all the paths via dfs
	time : 0.16s
	"""
	graph = createOptimizedGraph(routes)
	for couple in permutationsFromOrigin(cities):
		if couple is not None:
			#yield find_all_paths2(graph,couple[0],couple[1])[0]
			path = find_all_paths2(graph,couple[0],couple[1])[0]
			if couple[0] in graph[path[-1]]:
				yield path

optimizedRoutePossibilities2(routes,cities)

def optimizedMinRoutePossibility(routes,startDate,cities,days):
	""" 
	take in argument routes and return all the paths via dfs
	time : 0.16s
	"""

	calendar = printListOfDates()
	indexStartDate = calendar.index(startDate)
	priceDatabase = createFakePriceDatabase(routes)
	lengthDays = len(days)
	# for i in days:
	# 	print(priceDatabase["MADRID-LISBONNE"][indexStartDate + i]) # 01/01/2017
	
	# for possibility in optimizedRoutePossibilities2(routes,cities):
	# 	for couple in permutationsReturnOrigin(possibility):
	# 		print(transformArray2(couple))
	sumPricesArray = []
	for possibility in optimizedRoutePossibilities2(routes,cities):
		i=0
		prices=[]
		print(possibility)
		for couple in permutationsReturnOrigin(possibility):
			print(couple)
			#print(priceDatabase[couple[0]+"-"+couple[1]])
			priceForDate = priceDatabase[couple[0]+"-"+couple[1]][indexStartDate + i]
			#print(priceForDate)
			prices += [priceForDate]
			i+=1
		print(prices)
		sumPrices = sum(prices)
		print(sumPrices)
		sumPricesArray+=[sumPrices]
	print(sumPricesArray)
	print(min(sumPricesArray))



optimizedMinRoutePossibility(routes,startDate,cities,days)

## TIME FUCTIONS
# def wrapper(func, *args, **kwargs):
#  	def wrapped():
#  		return func(*args, **kwargs)
#  	return wrapped

# #wrapped = wrapper(transformArray, routes)
# wrapped = wrapper(optimizedRoutePossibilities, routes,cities)
# #wrapped = wrapper(createOptimizedGraph, routes)

# print(timeit.timeit(wrapped, number=1000))




