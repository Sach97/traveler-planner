# we are receiving inputs from the mobile phone

# 	we are receiving the startCity
# 	we are receiving the startDate
# 	we are receiving the cities
# 	we are receiving the days
# 	we are receiving the routes ## ok

# make a function that take care of days 

from traveler_planner import printRoutePossibilities
from combinations import printCombinations
from combinations_on_list import printCombinationsArray
from depth_first_traversal import find_all_paths2
from permutations_origin import permutationsFromOrigin
from collections import defaultdict
from random import uniform
from list_of_dates import printListOfDates
from graph import Graph
import timeit
from datetime import date

# USER INPUTS
routes = [('MADRID','GRECE'),('MADRID','LISBONNE'),('GRECE','LISBONNE'),('GRECE','MADRID'),('LISBONNE','GRECE'),('LISBONNE','MADRID')] # generated by virtual table in sql on the device
days = [1,3]
startDate = date(2018, 1, 1)
startCity = "MADRID"
cities = ["MADRID","GRECE","LISBONNE"]

# OUTPUT
### TODO





def transformArray(routes):
	""" 
	take in argument routes and return it in a better format 
	time : 0.004s
	"""
	array=[]
	for couple in routes:
		array.append(couple[0]+ "-" +couple[1])

	return array

#print(transformArray(routes))


#WHAT WE HAVE IN DATABASE (prices)
def createFakePriceDatabase(routes):
	"""
	take in argument the routes generated by the device with the ryanair database of airports routes and return a fake database of prices 
	time : 1.7s
	"""

	transformedArray = transformArray(routes)
	priceDatabase = {key:[int(round(uniform(20, 180))) for _ in range(364)] for key in transformedArray}

	return priceDatabase

# GENERATED WITH USER INPUTS
def createOptimizedGraph(routes):
	""" 
	take the routes user inputs generated by sql and return an optimized graph
	time : 0.007s
	"""

	graphClass = Graph(routes, directed=True)

	return graphClass.getGraph()

def optimizedRoutePossibilities(routes,cities):
	""" 
	take in argument routes and return all the paths via dfs
	time : 0.16s
	"""
	graph = createOptimizedGraph(routes)
	for couple in permutationsFromOrigin(cities):
		if couple is not None:
			#yield find_all_paths2(graph,couple[0],couple[1])[0]
			print(find_all_paths2(graph,couple[0],couple[1])[0])

#optimizedRoutePossibilities(routes,cities)

def optimizedRoutePossibilities2(routes,cities):
	""" 
	take in argument routes and return all the paths via dfs
	time : 0.16s
	"""
	graph = createOptimizedGraph(routes)
	for couple in permutationsFromOrigin(cities):
		if couple is not None:
			#yield find_all_paths2(graph,couple[0],couple[1])[0]
			path = find_all_paths2(graph,couple[0],couple[1])[0]
			if couple[0] in graph[path[-1]]:
				print(path)

optimizedRoutePossibilities2(routes,cities)

def optimizedMinRoutePossibility(routes,startDate,cities):
	""" 
	take in argument routes and return all the paths via dfs
	time : 0.16s
	"""

	priceDatabase = createFakePriceDatabase(routes)
	calendar = printListOfDates()

	for possibility in optimizedRoutePossibilities(routes,cities):
		print(possibility)

#optimizedMinRoutePossibility(routes,startDate,cities)



#print(optimizedMinRoutePossibility(routes,graph))

## TIME FUCTIONS
# def wrapper(func, *args, **kwargs):
#  	def wrapped():
#  		return func(*args, **kwargs)
#  	return wrapped

# #wrapped = wrapper(transformArray, routes)
# wrapped = wrapper(optimizedRoutePossibilities, routes,cities)
# #wrapped = wrapper(createOptimizedGraph, routes)

# print(timeit.timeit(wrapped, number=1000))




